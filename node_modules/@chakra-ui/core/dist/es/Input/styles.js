import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { useTheme } from "../ThemeProvider";
import { useColorMode } from "../ColorModeProvider";

var outlinedStyle = function outlinedStyle(_ref) {
  var _ref$focusBorderColor = _ref.focusBorderColor,
      focusBorderColor = _ref$focusBorderColor === void 0 ? "blue" : _ref$focusBorderColor,
      colors = _ref.theme.colors,
      colorMode = _ref.colorMode;
  var bg = {
    light: "white",
    dark: "whiteAlpha.100"
  };
  var borderColor = {
    light: "inherit",
    dark: "whiteAlpha.50"
  };
  var hoverColor = {
    light: "gray.300",
    dark: "whiteAlpha.200"
  };
  var boxShadow = colors[focusBorderColor] && colors[focusBorderColor][500];
  var invalidColor = {
    light: "red.500",
    dark: "red.300"
  };
  var invalidBoxShadow = {
    light: colors.red[500],
    dark: colors.red[300]
  };
  return _objectSpread({}, readOnly, {
    border: "1px",
    borderColor: borderColor[colorMode],
    bg: bg[colorMode],
    _hover: {
      borderColor: hoverColor[colorMode]
    },
    _disabled: {
      opacity: "0.4",
      cursor: "not-allowed"
    },
    _focus: {
      borderColor: focusBorderColor + ".500",
      boxShadow: "0 0 0 1px " + boxShadow
    },
    _invalid: {
      borderColor: invalidColor[colorMode],
      boxShadow: "0 0 0 1px " + invalidBoxShadow[colorMode]
    }
  });
};

var readOnly = {
  _readOnly: {
    bg: "transparent",
    boxShadow: "none !important",
    userSelect: "all"
  }
};

var filledStyle = function filledStyle(_ref2) {
  var focusBorderColor = _ref2.focusBorderColor,
      colorMode = _ref2.colorMode;
  var bg = {
    light: "gray.100",
    dark: "whiteAlpha.50"
  };
  var hoverColor = {
    light: "gray.200",
    dark: "whiteAlpha.100"
  };
  var invalidColor = {
    light: "red.500",
    dark: "red.300"
  };
  var focusColor = {
    light: focusBorderColor + ".500",
    dark: focusBorderColor + ".300"
  };
  return _objectSpread({}, readOnly, {
    border: "2px",
    borderColor: "transparent",
    bg: bg[colorMode],
    _hover: {
      bg: hoverColor[colorMode]
    },
    _disabled: {
      opacity: "0.4",
      cursor: "not-allowed"
    },
    _focus: {
      bg: "transparent",
      borderColor: focusColor[colorMode]
    },
    _invalid: {
      borderColor: invalidColor[colorMode]
    }
  });
};

var flushedStyle = function flushedStyle(_ref3) {
  var colorMode = _ref3.colorMode;
  var focusColor = {
    light: "blue.500",
    dark: "blue.300"
  };
  var errorColor = {
    light: "red.500",
    dark: "red.300"
  };
  return _objectSpread({}, readOnly, {
    borderBottom: "2px",
    borderColor: "inherit",
    rounded: 0,
    px: undefined,
    bg: "transparent",
    _focus: {
      borderColor: focusColor[colorMode]
    },
    _invalid: {
      borderColor: errorColor[colorMode]
    }
  });
};

var unstyledStyle = {
  bg: "transparent",
  px: undefined,
  height: undefined
};

var variantProps = function variantProps(props) {
  switch (props.variant) {
    case "flushed":
      return flushedStyle(props);

    case "unstyled":
      return unstyledStyle;

    case "filled":
      return filledStyle(props);

    case "outline":
      return outlinedStyle(props);

    default:
      return {};
  }
};

var baseProps = {
  display: "flex",
  alignItems: "center",
  position: "relative",
  transition: "all 0.2s",
  outline: "none"
};
export var inputSizes = {
  lg: {
    fontSize: "lg",
    px: 4,
    height: 12,
    lineHeight: "3rem",
    rounded: "md"
  },
  md: {
    fontSize: "md",
    px: 4,
    height: 10,
    lineHeight: "2.5rem",
    rounded: "md"
  },
  sm: {
    fontSize: "sm",
    px: 3,
    height: 8,
    lineHeight: "2rem",
    rounded: "sm"
  }
};

var sizeProps = function sizeProps(props) {
  return inputSizes[props.size];
};

var useInputStyle = function useInputStyle(props) {
  var theme = useTheme();

  var _useColorMode = useColorMode(),
      colorMode = _useColorMode.colorMode;

  var _props = _objectSpread({}, props, {
    theme: theme,
    colorMode: colorMode
  });

  return _objectSpread({
    width: props.isFullWidth ? "100%" : undefined
  }, baseProps, {}, sizeProps(_props), {}, variantProps(_props));
};

export default useInputStyle;