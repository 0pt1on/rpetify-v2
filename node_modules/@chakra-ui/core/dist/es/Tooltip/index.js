import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _taggedTemplateLiteralLoose from "@babel/runtime/helpers/taggedTemplateLiteralLoose";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n  ", "\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

/** @jsx jsx */
import { jsx } from "@emotion/core";
import styled from "@emotion/styled";
import Portal from "@reach/portal";
import { cloneElement, useRef, Children } from "react";
import { Manager, Popper, Reference } from "react-popper";
import { assignRef, genId } from "../utils";
import { PopoverTransition, popperStyle } from "../Popover/components";
import { useColorMode } from "../ColorModeProvider";
import Box from "../Box";
import useDisclosure from "../useDisclosure";
import { useId } from "@reach/auto-id";
var TooltipContent = styled(Box)(_templateObject(), popperStyle);

var Tooltip = function Tooltip(_ref) {
  var bg = _ref.bg,
      color = _ref.color,
      label = _ref.label,
      _ref$showDelay = _ref.showDelay,
      showDelay = _ref$showDelay === void 0 ? 100 : _ref$showDelay,
      _ref$hideDelay = _ref.hideDelay,
      hideDelay = _ref$hideDelay === void 0 ? 100 : _ref$hideDelay,
      _ref$transitionDurati = _ref.transitionDuration,
      transitionDuration = _ref$transitionDurati === void 0 ? 50 : _ref$transitionDurati,
      _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? "auto" : _ref$placement,
      children = _ref.children,
      showArrow = _ref.showArrow,
      closeOnClick = _ref.closeOnClick,
      defaultIsOpen = _ref.defaultIsOpen,
      controlledIsOpen = _ref.isOpen,
      onOpenChange = _ref.onOpenChange,
      rest = _objectWithoutPropertiesLoose(_ref, ["bg", "color", "label", "showDelay", "hideDelay", "transitionDuration", "placement", "children", "showArrow", "closeOnClick", "defaultIsOpen", "isOpen", "onOpenChange"]);

  var _useDisclosure = useDisclosure(defaultIsOpen || false),
      isOpen = _useDisclosure.isOpen,
      onClose = _useDisclosure.onClose,
      onOpen = _useDisclosure.onOpen;

  var _useRef = useRef(controlledIsOpen != null),
      isControlled = _useRef.current;

  var _isOpen = isControlled ? controlledIsOpen : isOpen;

  var openWithDelay = function openWithDelay() {
    setTimeout(onOpen, showDelay);
  };

  var closeWithDelay = function closeWithDelay() {
    setTimeout(onClose, hideDelay);
  };

  var tooltipId = "tooltip-" + useId();

  var handleOpen = function handleOpen() {
    !isControlled && openWithDelay();
    onOpenChange && onOpenChange();
  };

  var handleClose = function handleClose() {
    !isControlled && closeWithDelay();
    onOpenChange && onOpenChange();
  };

  var _useColorMode = useColorMode(),
      colorMode = _useColorMode.colorMode;

  var _bg = colorMode === "dark" ? "gray.300" : "gray.700";

  var _color = colorMode === "dark" ? "gray.900" : "whiteAlpha.900";

  var bgColor = bg || _bg;
  var textColor = color || _color;
  var child = typeof children === "string" ? children : Children.only(children);

  var handleClick = function handleClick(event) {
    closeOnClick && closeWithDelay();

    if (typeof children !== "string") {
      child.props.onClick && child.props.onClick(event);
    }
  };

  return jsx(Manager, null, jsx(Reference, null, function (_ref2) {
    var referenceRef = _ref2.ref;
    // Props for the reference element.
    var referenceProps = {
      "aria-labelledby": tooltipId,
      ref: function ref(node) {
        assignRef(referenceRef, node);
      },
      onMouseEnter: handleOpen,
      onMouseLeave: handleClose,
      onClick: handleClick,
      onFocus: handleOpen,
      onBlur: handleClose
    }; // If you pass just a string to the Tooltip children,
    // let's wrap it in a span as a fallback

    if (typeof child === "string") {
      return jsx(Box, _extends({
        as: "span"
      }, referenceProps), child);
    }

    return cloneElement(child, _objectSpread({}, referenceProps));
  }), jsx(Popper, {
    placement: placement
  }, function (_ref3) {
    var popperRef = _ref3.ref,
        style = _ref3.style,
        arrowProps = _ref3.arrowProps,
        placement = _ref3.placement;
    return jsx(PopoverTransition, {
      duration: transitionDuration,
      isOpen: _isOpen
    }, function (styles) {
      return jsx(Portal, null, jsx(TooltipContent, _extends({
        ref: popperRef,
        px: "8px",
        py: "2px",
        id: tooltipId,
        role: "tooltip",
        bg: bgColor,
        borderRadius: "sm",
        fontWeight: "medium",
        color: textColor,
        css: _objectSpread({}, style, {
          transform: "" + style.transform,
          opacity: styles.opacity
        }),
        "data-placement": placement,
        fontSize: "sm",
        boxShadow: "md",
        maxWidth: "320px"
      }, rest), label, showArrow && jsx(Box, {
        borderColor: bgColor,
        "data-arrow": "",
        ref: arrowProps.ref,
        style: arrowProps.style
      })));
    });
  }));
};

export default Tooltip;