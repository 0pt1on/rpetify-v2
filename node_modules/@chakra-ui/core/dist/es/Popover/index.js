import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/** @jsx jsx */
import { jsx } from "@emotion/core";
import { useId } from "@reach/auto-id";
import Portal from "@reach/portal";
import { cloneElement, Fragment, useEffect, useRef } from "react";
import { Manager, Popper, Reference } from "react-popper";
import Box from "../Box";
import { useColorMode } from "../ColorModeProvider";
import useDisclosure from "../useDisclosure";
import { assignRef } from "../utils";
import FocusLock from "react-focus-lock";
import { PopoverCloseButton, PopoverContent, PopoverTransition } from "./components";

var Popover = function Popover(_ref) {
  var controlledIsOpen = _ref.isOpen,
      defaultIsOpen = _ref.defaultIsOpen,
      _ref$maxWidth = _ref.maxWidth,
      maxWidth = _ref$maxWidth === void 0 ? "xs" : _ref$maxWidth,
      trigger = _ref.trigger,
      gutter = _ref.gutter,
      placement = _ref.placement,
      children = _ref.children,
      showArrow = _ref.showArrow,
      showCloseButton = _ref.showCloseButton,
      _ref$usePortal = _ref.usePortal,
      usePortal = _ref$usePortal === void 0 ? true : _ref$usePortal,
      onOpenChange = _ref.onOpenChange,
      _ref$trapFocus = _ref.trapFocus,
      trapFocus = _ref$trapFocus === void 0 ? false : _ref$trapFocus,
      _ref$closeOnBlur = _ref.closeOnBlur,
      closeOnBlur = _ref$closeOnBlur === void 0 ? true : _ref$closeOnBlur,
      _ref$closeOnEsc = _ref.closeOnEsc,
      closeOnEsc = _ref$closeOnEsc === void 0 ? true : _ref$closeOnEsc,
      rest = _objectWithoutPropertiesLoose(_ref, ["isOpen", "defaultIsOpen", "maxWidth", "trigger", "gutter", "placement", "children", "showArrow", "showCloseButton", "usePortal", "onOpenChange", "trapFocus", "closeOnBlur", "closeOnEsc"]);

  var _useDisclosure = useDisclosure(defaultIsOpen),
      isOpen = _useDisclosure.isOpen,
      onClose = _useDisclosure.onClose,
      onToggle = _useDisclosure.onToggle;

  var triggerRef = useRef();
  var popperRef = useRef();
  useEffect(function () {
    onOpenChange && onOpenChange(isOpen);
  }, [isOpen, onOpenChange]);

  var handleBlur = function handleBlur(event) {
    if (!trapFocus && isOpen && popperRef.current && triggerRef.current && !popperRef.current.contains(event.relatedTarget) && !triggerRef.current.contains(event.relatedTarget)) {
      closeOnBlur && onClose();
    }
  };

  var _useColorMode = useColorMode(),
      colorMode = _useColorMode.colorMode;

  var _bgColor = colorMode === "light" ? "white" : "gray.700";

  var bg = rest.bg || rest.background || rest.backgroundColor || _bgColor;
  var popoverId = "popper-" + useId();
  var PopperWrapper = usePortal ? Portal : Fragment;
  return jsx(Manager, null, jsx(Reference, null, function (_ref2) {
    var referenceRef = _ref2.ref;
    return cloneElement(trigger, {
      "aria-haspopup": "true",
      "aria-controls": popoverId,
      ref: function ref(node) {
        triggerRef.current = node;
        assignRef(referenceRef, node);
      },
      onClick: function onClick(event) {
        onToggle();
        trigger.props.onClick && trigger.props.onClick(event);
      }
    });
  }), jsx(PopperWrapper, null, jsx(Popper, {
    placement: placement
  }, function (_ref3) {
    var _ref4 = _ref3.ref,
        popperStyle = _ref3.style,
        placement = _ref3.placement,
        arrowProps = _ref3.arrowProps;
    return jsx(PopoverTransition, {
      duration: 100,
      isOpen: isOpen
    }, function (styles) {
      return jsx(FocusLock // eslint-disable-next-line jsx-a11y/no-autofocus
      , {
        autoFocus: false,
        returnFocus: true
      }, jsx(PopoverContent, _extends({
        ref: function ref(node) {
          popperRef.current = node;
          assignRef(_ref4, node);
        },
        bg: bg,
        maxWidth: maxWidth,
        "data-placement": placement,
        id: popoverId,
        "aria-hidden": isOpen
      }, rest, {
        tabIndex: "-1",
        onBlur: handleBlur,
        css: _objectSpread({}, popperStyle, {
          transform: popperStyle.transform + " scale(" + styles.scale + ")",
          opacity: styles.opacity
        }),
        onKeyDown: function onKeyDown(event) {
          event.stopPropagation();

          if (event.key === "Escape" && closeOnEsc) {
            onClose && onClose();
          }
        }
      }), showCloseButton && jsx(PopoverCloseButton, {
        onClick: onClose
      }), typeof children === "function" ? children({
        isOpen: isOpen,
        onClose: onClose
      }) : children, showArrow && jsx(Box, {
        borderColor: bg,
        "data-arrow": "",
        ref: arrowProps.ref,
        css: arrowProps.style
      })));
    });
  })));
};

export default Popover;
export * from "./components";