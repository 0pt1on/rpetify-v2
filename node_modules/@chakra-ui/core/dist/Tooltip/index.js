"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _taggedTemplateLiteralLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteralLoose"));

var _core = require("@emotion/core");

var _styled = _interopRequireDefault(require("@emotion/styled"));

var _portal = _interopRequireDefault(require("@reach/portal"));

var _react = require("react");

var _reactPopper = require("react-popper");

var _utils = require("../utils");

var _components = require("../Popover/components");

var _ColorModeProvider = require("../ColorModeProvider");

var _Box = _interopRequireDefault(require("../Box"));

var _useDisclosure2 = _interopRequireDefault(require("../useDisclosure"));

var _autoId = require("@reach/auto-id");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _templateObject() {
  var data = (0, _taggedTemplateLiteralLoose2["default"])(["\n  ", "\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var TooltipContent = (0, _styled["default"])(_Box["default"])(_templateObject(), _components.popperStyle);

var Tooltip = function Tooltip(_ref) {
  var bg = _ref.bg,
      color = _ref.color,
      label = _ref.label,
      _ref$showDelay = _ref.showDelay,
      showDelay = _ref$showDelay === void 0 ? 100 : _ref$showDelay,
      _ref$hideDelay = _ref.hideDelay,
      hideDelay = _ref$hideDelay === void 0 ? 100 : _ref$hideDelay,
      _ref$transitionDurati = _ref.transitionDuration,
      transitionDuration = _ref$transitionDurati === void 0 ? 50 : _ref$transitionDurati,
      _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? "auto" : _ref$placement,
      children = _ref.children,
      showArrow = _ref.showArrow,
      closeOnClick = _ref.closeOnClick,
      defaultIsOpen = _ref.defaultIsOpen,
      controlledIsOpen = _ref.isOpen,
      onOpenChange = _ref.onOpenChange,
      rest = (0, _objectWithoutPropertiesLoose2["default"])(_ref, ["bg", "color", "label", "showDelay", "hideDelay", "transitionDuration", "placement", "children", "showArrow", "closeOnClick", "defaultIsOpen", "isOpen", "onOpenChange"]);

  var _useDisclosure = (0, _useDisclosure2["default"])(defaultIsOpen || false),
      isOpen = _useDisclosure.isOpen,
      onClose = _useDisclosure.onClose,
      onOpen = _useDisclosure.onOpen;

  var _useRef = (0, _react.useRef)(controlledIsOpen != null),
      isControlled = _useRef.current;

  var _isOpen = isControlled ? controlledIsOpen : isOpen;

  var openWithDelay = function openWithDelay() {
    setTimeout(onOpen, showDelay);
  };

  var closeWithDelay = function closeWithDelay() {
    setTimeout(onClose, hideDelay);
  };

  var tooltipId = "tooltip-" + (0, _autoId.useId)();

  var handleOpen = function handleOpen() {
    !isControlled && openWithDelay();
    onOpenChange && onOpenChange();
  };

  var handleClose = function handleClose() {
    !isControlled && closeWithDelay();
    onOpenChange && onOpenChange();
  };

  var _useColorMode = (0, _ColorModeProvider.useColorMode)(),
      colorMode = _useColorMode.colorMode;

  var _bg = colorMode === "dark" ? "gray.300" : "gray.700";

  var _color = colorMode === "dark" ? "gray.900" : "whiteAlpha.900";

  var bgColor = bg || _bg;
  var textColor = color || _color;
  var child = typeof children === "string" ? children : _react.Children.only(children);

  var handleClick = function handleClick(event) {
    closeOnClick && closeWithDelay();

    if (typeof children !== "string") {
      child.props.onClick && child.props.onClick(event);
    }
  };

  return (0, _core.jsx)(_reactPopper.Manager, null, (0, _core.jsx)(_reactPopper.Reference, null, function (_ref2) {
    var referenceRef = _ref2.ref;
    // Props for the reference element.
    var referenceProps = {
      "aria-labelledby": tooltipId,
      ref: function ref(node) {
        (0, _utils.assignRef)(referenceRef, node);
      },
      onMouseEnter: handleOpen,
      onMouseLeave: handleClose,
      onClick: handleClick,
      onFocus: handleOpen,
      onBlur: handleClose
    }; // If you pass just a string to the Tooltip children,
    // let's wrap it in a span as a fallback

    if (typeof child === "string") {
      return (0, _core.jsx)(_Box["default"], (0, _extends2["default"])({
        as: "span"
      }, referenceProps), child);
    }

    return (0, _react.cloneElement)(child, _objectSpread({}, referenceProps));
  }), (0, _core.jsx)(_reactPopper.Popper, {
    placement: placement
  }, function (_ref3) {
    var popperRef = _ref3.ref,
        style = _ref3.style,
        arrowProps = _ref3.arrowProps,
        placement = _ref3.placement;
    return (0, _core.jsx)(_components.PopoverTransition, {
      duration: transitionDuration,
      isOpen: _isOpen
    }, function (styles) {
      return (0, _core.jsx)(_portal["default"], null, (0, _core.jsx)(TooltipContent, (0, _extends2["default"])({
        ref: popperRef,
        px: "8px",
        py: "2px",
        id: tooltipId,
        role: "tooltip",
        bg: bgColor,
        borderRadius: "sm",
        fontWeight: "medium",
        color: textColor,
        css: _objectSpread({}, style, {
          transform: "" + style.transform,
          opacity: styles.opacity
        }),
        "data-placement": placement,
        fontSize: "sm",
        boxShadow: "md",
        maxWidth: "320px"
      }, rest), label, showArrow && (0, _core.jsx)(_Box["default"], {
        borderColor: bgColor,
        "data-arrow": "",
        ref: arrowProps.ref,
        style: arrowProps.style
      })));
    });
  }));
};

var _default = Tooltip;
exports["default"] = _default;